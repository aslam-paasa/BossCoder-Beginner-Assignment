Time and Space Complexity Theoretical Analysis:
1. O(1) = Operations, Array
2. O(n) = Linear Search, Power1, Power3, for1, for2, [for*for]
3. O(logn) = Binary Search, Power2, for3, for4
4. O(n^2) = Bubble Sort, Selection Sort, Insertion Sort, for5
5. O(2^n) = printss, fib
6. O(nlogn) = Merge, Quick, Arrays.sort, Collection.sort
7. Amortized Analysis = ArrayList, StringBuilder
8. Polynomial = 1.x^n + 2.x^(n-1) + 3.x^(n-2) + ... + n.x^1
9. Sieve of Eratosthenes
10. Check Duplicates
11. Highest Frequency Character
12. Sort01, odd-even, move 0's to end
13. Sort012, Sort lo-hi
13. Target sum pair
14. Target sum triplet
15. One unique rest twice
16. Two unique rest twice


Q) for*for but still O(n). Why?

for(int i = 1; i <= n; i += c) {
    for(int j = 1; j <= c; j++) {
        // do some k work
    }
}

=> for*for kvi kvi O(n^2) k jagha O(n) v ho skta hai.
=> Dekhnge ki bahar wala loop kitni baar chlega aur andr wala loop kitni
   baar chalega

for(int i = 1; i <= n; i += c) {

}

=> Bahar wala loop har baar 'c' se increase kr rha hai. To bahar wla 
   loop n/c se badhne wala hai.
=> Example, n = 1000, c = 50 => Bahar wala loop kitni baar chalega?
   Ek baar chaleaga to 50 se badhega, to 51 hoga, then 101, 151, 201 etc.
   It means n=1000 hai, c=50 hai to n/c se badhega i.e. 20 times chlega.
=> Bahar wala loop chlega n/c baar aur andr wala loop chlega 'c' baar.
   To andr wala loop total chlega 'n/c * c' baar. => c se c kat gya that
   means total loop chlega 'n' baar. Aur har baar wo kaam kr rha hai 'k'
   to total complexity 'n*k'. => O(n)

=> T.C. = n/c * c * k => kn.

Note: Ab hum kuch sorting krnge jo hum kvi use nhi krnge. Lekin complexity
      k liye humein pdhna padta hai.  

Interview m Bubble, Merge koi nhi puchega lekin humein aani hi chaiye
Ab hum aage saare O(n^2) wali problems karenge:
(a) Bubble Sort
(b) Selection Sort
(c) Insertion Sort 
(d) for5 



Maths for DP: (Read: Brilliant.org => 15 min each topic)
1. Combinatorics
2. Series
3. Set Theory
4. Logarithm
5. Functions and Relations